[
  {
    "task_name": "complete_function",
    "category": "code_completion",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 64,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "```kotlin\nfun factorial(n: Int): Long {\n    if (n < 0) {\n        throw IllegalArgumentException(\"Factorial is not defined for negative numbers\")\n    } else if (n == 0 || n == 1) {\n        return 1L\n    } else {\n        return n.to",
    "time_seconds": 4.5,
    "tokens_generated": 64,
    "tokens_per_second": 14.2,
    "expected_found": 3,
    "expected_total": 4,
    "success_rate": 75.0
  },
  {
    "task_name": "complete_function",
    "category": "code_completion",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 128,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "```kotlin\nfun factorial(n: Int): Long {\n    if (n < 0) {\n        throw IllegalArgumentException(\"Factorial is not defined for negative numbers\")\n    } else if (n == 0 || n == 1) {\n        return 1L\n    } else {\n        return n.toLong() * factorial(n - 1)\n    }\n}\n```",
    "time_seconds": 10.06,
    "tokens_generated": 78,
    "tokens_per_second": 7.8,
    "expected_found": 4,
    "expected_total": 4,
    "success_rate": 100.0
  },
  {
    "task_name": "complete_function",
    "category": "code_completion",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 256,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "```kotlin\nfun factorial(n: Int): Long {\n    if (n < 0) {\n        throw IllegalArgumentException(\"Factorial is not defined for negative numbers\")\n    } else if (n == 0 || n == 1) {\n        return 1L\n    } else {\n        return n.toLong() * factorial(n - 1)\n    }\n}\n```",
    "time_seconds": 9.22,
    "tokens_generated": 78,
    "tokens_per_second": 8.5,
    "expected_found": 4,
    "expected_total": 4,
    "success_rate": 100.0
  },
  {
    "task_name": "complete_function",
    "category": "code_completion",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 512,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "```kotlin\nfun factorial(n: Int): Long {\n    return if (n == 0) {\n        1L\n    } else {\n        n.toLong() * factorial(n - 1)\n    }\n}\n```",
    "time_seconds": 5.12,
    "tokens_generated": 48,
    "tokens_per_second": 9.4,
    "expected_found": 4,
    "expected_total": 4,
    "success_rate": 100.0
  },
  {
    "task_name": "fix_off_by_one",
    "category": "code_fix",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 64,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "**Bug Explanation**\n\nThe bug in this code is that it attempts to access an element at the index equal to the length of the array, which is out of bounds. In Python (and most programming languages), indices start from 0, so the last valid index for a list with `n` elements is `n",
    "time_seconds": 8.04,
    "tokens_generated": 64,
    "tokens_per_second": 8.0,
    "expected_found": 0,
    "expected_total": 2,
    "success_rate": 0.0
  },
  {
    "task_name": "fix_off_by_one",
    "category": "code_fix",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 128,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "**Bug Explanation**\n\nThe bug in this code is that it attempts to access an index that does not exist in the array. In Python, arrays are 0-indexed, meaning the last valid index of an array is always `len(arr) - 1`, not `len(arr)`.\n\nWhen you try to access `arr[len(arr)]`, Python raises an `IndexError` because it's trying to access an index that doesn't exist. This error occurs when you're trying to access a sequence (like a list or string) with an index that is out of range.\n\n**Fix**\n\nTo fix this",
    "time_seconds": 15.0,
    "tokens_generated": 128,
    "tokens_per_second": 8.5,
    "expected_found": 1,
    "expected_total": 2,
    "success_rate": 50.0
  },
  {
    "task_name": "fix_off_by_one",
    "category": "code_fix",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 256,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "**Bug Explanation**\n\nThe bug in the provided code is that it attempts to access an element at the index equal to the length of the array. In Python, list indices start from 0, not 1. Therefore, when you try to access `arr[len(arr)]`, you are trying to access an index that does not exist.\n\nFor example, if the input array is `[1, 2, 3]`, `len(arr)` would be 3, and attempting to access `arr[3]` would result in an `IndexError`.\n\n**Fix**\n\nTo fix this bug, we need to change the code so that it returns",
    "time_seconds": 28.35,
    "tokens_generated": 256,
    "tokens_per_second": 9.0,
    "expected_found": 2,
    "expected_total": 2,
    "success_rate": 100.0
  },
  {
    "task_name": "fix_off_by_one",
    "category": "code_fix",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 512,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "**Bug Explanation**\n\nThe bug in this code is that it attempts to access an element at the index equal to the length of the array, which is out of bounds.\n\nIn Python, list indices start at 0, meaning the last valid index of a list with `n` elements is `n-1`. Therefore, trying to access `arr[len(arr)]` will result in an `IndexError`, as this index does not exist.\n\n**Fix**\n\nTo fix this bug, we need to change the return statement to access the last element correctly. Since Python uses 0-based indexi",
    "time_seconds": 33.44,
    "tokens_generated": 296,
    "tokens_per_second": 8.9,
    "expected_found": 2,
    "expected_total": 2,
    "success_rate": 100.0
  },
  {
    "task_name": "explain_recursion",
    "category": "explanation",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 64,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "This code defines a recursive function called `mystery` that calculates the nth number in a sequence, where each term is the sum of the two preceding terms (a classic example of a Fibonacci sequence). The base case for the recursion is when n is 1 or less, at which point the function returns n. Otherwise",
    "time_seconds": 7.82,
    "tokens_generated": 64,
    "tokens_per_second": 8.2,
    "expected_found": 2,
    "expected_total": 2,
    "success_rate": 100.0
  },
  {
    "task_name": "explain_recursion",
    "category": "explanation",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 128,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "This code defines a recursive function named `mystery` that calculates the nth Fibonacci number, where each number is the sum of the two preceding ones (i.e., 0 and 1). The base case for the recursion is when `n` is less than or equal to 1, in which case it returns `n`. Otherwise, it calls itself with decreasing values of `n`, effectively computing the Fibonacci sequence.",
    "time_seconds": 10.42,
    "tokens_generated": 86,
    "tokens_per_second": 8.3,
    "expected_found": 2,
    "expected_total": 2,
    "success_rate": 100.0
  },
  {
    "task_name": "explain_recursion",
    "category": "explanation",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 256,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "This code defines a recursive function called `mystery` that calculates the nth Fibonacci number. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. This function uses recursion to calculate the nth number in this sequence by breaking it down into smaller instances of itself.",
    "time_seconds": 8.21,
    "tokens_generated": 70,
    "tokens_per_second": 8.5,
    "expected_found": 2,
    "expected_total": 2,
    "success_rate": 100.0
  },
  {
    "task_name": "explain_recursion",
    "category": "explanation",
    "model": "llama3.2:latest",
    "temperature": 0.3,
    "max_tokens": 512,
    "num_ctx": 2048,
    "quantization": "Q4_K_M",
    "response": "This code defines a recursive function called `mystery` that calculates the nth Fibonacci number. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. This function uses recursion to break down the problem into smaller sub-problems until it reaches the base case (when n is 1 or less), at which point it starts returning the results back up the call stack.",
    "time_seconds": 10.35,
    "tokens_generated": 91,
    "tokens_per_second": 8.8,
    "expected_found": 2,
    "expected_total": 2,
    "success_rate": 100.0
  }
]